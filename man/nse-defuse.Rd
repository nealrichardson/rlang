% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nse-defuse.R
\name{nse-defuse}
\alias{nse-defuse}
\alias{quotation}
\alias{expr}
\alias{enquo}
\alias{enquos}
\title{Defuse R expressions}
\usage{
expr(expr)

enquo(arg)

enquos(
  ...,
  .named = FALSE,
  .ignore_empty = c("trailing", "none", "all"),
  .unquote_names = TRUE,
  .homonyms = c("keep", "first", "last", "error"),
  .check_assign = FALSE
)
}
\arguments{
\item{expr}{An expression.}

\item{arg}{A symbol representing an argument. The expression
supplied to that argument will be captured instead of being
evaluated.}

\item{...}{For \code{enexprs()}, \code{ensyms()} and \code{enquos()}, names of
arguments to capture without evaluation (including \code{...}). For
\code{exprs()} and \code{quos()}, the expressions to capture unevaluated
(including expressions contained in \code{...}).}

\item{.named}{If \code{TRUE}, unnamed inputs are automatically named
with \code{\link[=as_label]{as_label()}}. This is equivalent to applying
\code{\link[=exprs_auto_name]{exprs_auto_name()}} on the result. If \code{FALSE}, unnamed elements
are left as is and, if fully unnamed, the list is given minimal
names (a vector of \code{""}). If \code{NULL}, fully unnamed results are
left with \code{NULL} names.}

\item{.ignore_empty}{Whether to ignore empty arguments. Can be one
of \code{"trailing"}, \code{"none"}, \code{"all"}. If \code{"trailing"}, only the
last argument is ignored if it is empty. Named arguments are not
considered empty.}

\item{.unquote_names}{Whether to treat \verb{:=} as \code{=}. Unlike \code{=}, the
\verb{:=} syntax supports \verb{!!} unquoting on the LHS.}

\item{.homonyms}{How to treat arguments with the same name. The
default, \code{"keep"}, preserves these arguments. Set \code{.homonyms} to
\code{"first"} to only keep the first occurrences, to \code{"last"} to keep
the last occurrences, and to \code{"error"} to raise an informative
error and indicate what arguments have duplicated names.}

\item{.check_assign}{Whether to check for \verb{<-} calls passed in
dots. When \code{TRUE} and a \verb{<-} call is detected, a warning is
issued to advise users to use \code{=} if they meant to match a
function parameter, or wrap the \verb{<-} call in braces otherwise.
This ensures assignments are explicit.}
}
\description{
\emph{Note regarding tidyverse programming:} \code{expr()} and \code{enquo()} are
advanced tidy eval operators. Most cases can be solved with \verb{\{\{}
and \code{...}. You can read about this in \link[=embracing]{embracing and forwarding}.

The defusing operators \code{expr()} and \code{enquo()} disable evaluation of
R code. When a piece of R code is defused, R doesn't return its
value like it normally would. Instead it returns the expression in
a special tree-like object that describes how to produce the value.
These defused expressions can be thought of as blueprints for
computing values.\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Return the result of `1 + 1`
1 + 1
}\if{html}{\out{</div>}}\preformatted{## [1] 2
}\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Return the expression `1 + 1`
expr(1 + 1)
}\if{html}{\out{</div>}}\preformatted{## 1 + 1
}\if{html}{\out{<div class="sourceCode r">}}\preformatted{# Return the expression and evaluate it
e <- expr(1 + 1)
eval(e)
}\if{html}{\out{</div>}}\preformatted{## [1] 2
}

There are two main ways to defuse expressions, to which correspond
the two functions \code{expr()} and \code{enquo()}:
\itemize{
\item You can defuse your \emph{own} R expressions with \code{expr()}.
\item You can defuse the expressions supplied by \emph{the user} of your
function with the \code{en}-prefixed operators, such as \code{enquo()} and
\code{enquos()}. These operators defuse function arguments.
}

One purpose for defusing evaluation of an expression is to
interface with data-masking functions with the
\strong{defuse-and-inject} pattern. Function arguments referring to
data-variables are defused and then injected with \verb{!!} or \verb{!!!} in
a data-masking function where the data-variables are defined.\preformatted{my_summarise <- function(data, arg) \{
  # Defuse the user expression in `arg`
  arg <- enquo(arg)

  # Inject the expression contained in `arg`
  # inside a `summarise()` argument
  data |> dplyr::summarise(mean = mean(!!arg, na.rm = TRUE))
\}
}

This pattern of defuse-and-inject can be done in one step with the
embracing operator \verb{\{\{} described in \link[=embracing]{embracing and forwarding}.\preformatted{my_summarise <- function(data, arg) \{
  # Defuse and inject in a single step with the embracing operator
  data |> dplyr::summarise(mean = mean(\{\{ arg \}\}, na.rm = TRUE))
\}
}

Using \code{enquo()} and \verb{!!} separately is useful for more complex
cases where you need access to the defused expression instead of
just passing it on.
}
\section{Defused arguments and quosures}{


If you inspect the return values of \code{expr()} and \code{enquo()}, you'll
notice that the latter doesn't return a raw expression like the
former. Instead it returns a \link{quosure}, a wrapper containing an
expression and an environment.\preformatted{expr(1 + 1)
#> 1 + 1

my_function <- function(arg) enquo(arg)
my_function(1 + 1)
#> <quosure>
#> expr: ^1 + 1
#> env:  global
}

R needs information about the environment to properly evaluate
argument expressions because they come from a different context
than the current function. For instance when a function in your
package calls \code{dplyr::mutate()}, the quosure environment indicates
where all the private functions of your package are defined.
}

\section{Comparison with base R}{


Defusing is known as \emph{quoting} in other frameworks.
\itemize{
\item The equivalent of \code{expr()} is \code{\link[base:bquote]{base::bquote()}}.
\item The equivalent of \code{enquo()} is \code{\link[base:substitute]{base::substitute()}}. The latter
returns a naked expression instead of a quosure.
\item There is no equivalent for \code{enquos(...)} but you can defuse dots
as a list of naked expressions with \code{eval(substitute(alist(...)))}.
}

What makes tidy eval work consistently and safely is that defused
argument expressions are wrapped in a \link{quosure}. Unlike a naked
expression, a quosure carries information about the context from
which an expression comes from. A quosure is evaluated in the
original environment of the expression, which allows R to find
local data and local functions.
}

\section{Types of defused expressions}{

\itemize{
\item \strong{Calls}, like \code{f(1, 2, 3)} or \code{1 + 1} represent the action of
calling a function to compute a new value, such as a vector.
\item \strong{Symbols}, like \code{x} or \code{df}, represent named objects. When the
object pointed to by the symbol was defined in a function or in
the global environment, we call it an environment-variable. When
the object is a column in a data frame, we call it a
data-variable.
\item \strong{Constants}, like \code{1} or \code{NULL}.
}

You can create new call or symbol objects by using the defusing
function \code{expr()}:\preformatted{# Create a symbol representing objects called `foo`
expr(foo)
#> foo

# Create a call representing the computation of the mean of `foo`
expr(mean(foo, na.rm = TRUE))
#> mean(foo, na.rm = TRUE)

# Return a constant
expr(1)
#> [1] 1

expr(NULL)
#> NULL
}

Defusing is not the only way to create defused expressions. You can
also assemble them from data:\preformatted{# Assemble a symbol from a string
var <- "foo"
sym(var)

# Assemble a call from strings, symbols, and constants
call("mean", sym(var), na.rm = TRUE)
}
}

\examples{
# `expr()` defuses the expression that you supply
expr(1 + 1)

# `enquo()` defuses the expression supplied by your user
my_function <- function(arg) {
  enquo(arg)
}
my_function(1 + 1)

# `enquos() works with arguments and dots and returns a list of
# expressions`
my_function <- function(...) {
  enquos(...)
}
my_function(1 + 1, 2 * 10)


# `expr()` and `enquo()` support _injection_, a convenient way of
# modifying part of an expression by injecting other objects.
column <- sym("cyl")
expr(mean(!!column, na.rm = TRUE))

columns <- syms(c("cyl", "am"))
expr(mean(!!columns[[1]] * !!columns[[2]], na.rm = TRUE))
expr(list(!!!columns))

# Using `enquo()` enables `{{ arg }}` embracing in particular
other_function <- function(arg) {
  my_function({{ arg }} * 2)
}
other_function(100)

other_function(!!column)
}
\seealso{
\code{\link[=enquo0]{enquo0()}} and \code{\link[=enquos0]{enquos0()}} for variants that do not
perform automatic injection/unquotation.
}
